# Implementation Plan for a League of Legends Tauri Companion App

## Architecture Overview (Tauri + React/Rust)

This application will use **Tauri** to combine a **Rust backend** with a **React/TypeScript frontend**, effectively creating two cooperating apps: a web-based UI and a native Rust process. The Rust backend will handle Riot API communication (keeping the API key and heavy logic secure and off the UI thread), while the React frontend will render the dashboard/overlay and handle user interaction. They will communicate via Tauri’s command and event system – e.g. the frontend can invoke Rust commands, and the Rust backend can emit events to update the UI state in real-time. This separation ensures maintainability: the frontend focuses on presentation (using familiar React patterns), and the backend manages data, API calls, and compliance logic.

**Key design considerations:** Keep the Riot API key and rate-limit logic in Rust (to avoid exposing secrets in the frontend code). Use asynchronous Rust tasks or threads to perform background polling of game status and player data, and then notify the UI through events. The UI will use React state or context to switch between the “Out-of-Game Dashboard” and “In-Game Match View” based on these events. This architecture will be responsive and secure – the heavy lifting happens off the UI thread, and only processed results are sent to the frontend, keeping the app smooth.

## 1. Game Loading Screen Detection (Pre-Game Monitoring)

**Goal:** Detect as soon as the target summoner starts a new match (enters the loading screen) by polling Riot’s public APIs across any PC (no local game client needed). The primary method will be the Riot **Spectator API**, which provides real-time info on live games. Specifically, we’ll use the `GET /lol/spectator/v4/active-games/by-summoner/{encryptedSummonerId}` endpoint. This returns the current game info if the player is in a match, or a 404 (Not Found) if they are not in a game. By polling this endpoint periodically (e.g. every 10 seconds), the app can detect a transition from “404 – not in game” to a live game payload, which indicates the user has entered a match. Ten-second polling is a reasonable starting point that stays well within Riot’s rate limits (see section 5) while providing near-real-time detection. If faster detection is needed, the interval could be lowered (e.g. 5 seconds), but we must ensure we remain within safe API call rates.

**Summoner ID lookup:** The Spectator API requires the user’s **encrypted Summoner ID** (unique per region) rather than the summoner name. On app startup or when the user enters a Summoner Name/Account ID, the backend will call the Summoner-V4 API to resolve the name to the Summoner ID (and PUUID, etc.). This is a one-time call per session per user, and we can cache the result. For example, `GET /lol/summoner/v4/summoners/by-name/{summonerName}` yields a JSON including `id` (the encrypted summoner ID) and `puuid`. We will store this `id` for use in the Spectator API polling loop.

**Polling loop implementation:** We will implement a background async task (or thread) in the Rust backend that wakes up every \~10 seconds and calls the Spectator API for the target summoner. In Rust, this could be done with a simple loop and `tokio::time::sleep`, or by spawning a thread that sleeps. When a response comes back with game data (HTTP 200), the backend will parse the JSON to a `CurrentGameInfo` object. At the **moment a new game is detected**, the Rust backend will emit an event to the frontend (e.g. an event `"gameStarted"`) carrying the game info payload. The React app will have a listener (via Tauri’s event API) to catch `"gameStarted"` and then transition the UI to the in-game dashboard view with the received data. (If needed, we can also handle the edge case of repeated detections: once a game is found, we might pause or reduce polling frequency to avoid redundant calls until that game ends.)

**Alternative detection methods:** If the app is running on the same PC as the game (and the user is tracking themselves), we could supplement this with the LoL *Live Client Data API* that runs locally on port 2999. That local API provides real-time events from the game client. However, relying on it would limit the cross-PC capability. To keep the solution general, we will primarily use Riot’s public APIs. Another fallback is checking the user’s match history for new matches (the Match-V5 API) – but that only confirms a game *after it’s finished*, not when it’s in loading. Therefore, the Spectator API is the optimal approach for timely detection of game start.

**Riot API compliance:** The polling must respect Riot’s rules. A 10-second interval yields 6 calls/minute, which is safe under the developer rate limit (100 calls per 2 minutes). We’ll implement proper error handling: if a 429 (rate limit exceeded) is ever returned, back off polling and resume at a slower rate after the window. In practice, with a single user being polled, we should never hit 100 calls in 2 minutes. (If we expand to track multiple summoners concurrently, we’d implement a queue to stagger calls, or use multiple API keys if authorized, but that’s beyond the single-user scope.)

## 2. Out-of-Game Persistent Dashboard (Detailed User Stats)

**Goal:** When the user is **not in a game**, the app shows a persistent dashboard of that player’s personal statistics and trends – similar to a profile page on sites like League of Graphs or Porofessor. This provides insight into the player’s overall performance, champion pool, and playstyle traits over recent history, helping identify strengths and weaknesses. We will populate this using the player’s match history data (using Riot’s Match-V5 API) and possibly other endpoints.

**Data collection:** We will fetch the user’s recent matches (for example, the last 20 ranked games) via the Match-V5 endpoint `GET /lol/match/v5/matches/by-puuid/{puuid}/ids`. Using the player’s PUUID (retrieved from Summoner-V4 earlier), we can get a list of recent match IDs. We can filter for ranked or normal queue as needed (the API supports a `queue` parameter for filtering by game type). With those match IDs, we then fetch match details (`/lol/match/v5/matches/{matchId}`) for each, or use aggregated endpoints if available. It’s important to cache these results to avoid redundant calls – e.g. store the last few match IDs and data in memory or on disk so we don’t refetch data that hasn’t changed between app runs. Since we primarily need summary stats (not real-time), we can afford to fetch and update this data relatively infrequently (e.g. refresh the dashboard stats every few minutes, or after a game ends).

**Displayed stats:** We will compute a variety of performance metrics and present them in a clear, visual manner. The focus is on **champion win rates, recent performance metrics, playstyle trends, and player traits** – akin to what League of Graphs provides from 30 days of data. Specifically, the dashboard will include:

* **Champion Performance:** The user’s most played champions (in the last 30 days or season) with win rates and KDA. For each top champion, show games played, win rate, and average KDA or other relevant stats. This is similar to Porofessor’s “player stats with current champion” and overall champion stats. It helps identify their comfort picks and success rates.

* **Recent Match Performance:** A summary of the last X games (e.g. 10 games) – win/loss record, average kills/deaths/assists, average CS (creep score) per game, and perhaps a **trend indicator** (are they improving or on a losing streak?). We could visualize this with a small chart (for example, a line graph of performance rating over the last games). Key metrics like average gold at 10 minutes, CS at 10, and damage per minute can be listed, since Porofessor specifically tracks those as indicators. These stats can be computed from the match details we fetched (the Match-V5 data includes timeline and stats for each participant, which we can aggregate).

* **Playstyle Trends & Traits:** Using the collected match data, we’ll analyze the player’s style. For example, we determine if the player is **aggressive** (high kill participation, early kills), a **farmer** (high CS/min but maybe lower kill participation), a **warder** (above-average wards placed), etc. League of Graphs and Porofessor derive such traits by comparing the player’s stats to average values in their rank or globally. We can implement a simplified version: calculate metrics like average CS per minute, wards per minute, kill participation, damage share, etc., and then highlight which areas are significantly above or below the norm. For instance, if the player’s CS per minute is in the bottom 20% compared to peers, we tag a trait like “Low Farming”. If their kill participation or damage share is extremely high, a trait like “Teamfighter” or “Carry Role” could be shown. The **League of Graphs “Playstyle”** section often categorizes players with tags (e.g. “Terrible when behind” or “Great farmer”) – we will emulate this concept. Internally, we’ll define thresholds (possibly using known stats or just based on percentiles from a large dataset). We may leverage external data if available (for a more advanced approach, but for this plan we assume we derive it from the user’s own history and known averages).

* **Traits Visualization:** We can present these traits as icons or short labels (tags) next to the player’s profile. For example, tags like “Early Aggression”, “Vision Control”, “Late Game Carrier” can be shown with tooltips explaining them. This is analogous to Porofessor’s tag system which quickly summarizes a player’s style. Each tag will be backed by a statistic – e.g. “Vision Dominance” tag if wards placed per minute > certain threshold.

To implement this efficiently, compute aggregate stats once when the dashboard is loaded. The Rust backend can crunch the numbers (e.g. average all relevant fields from the recent matches) and categorize traits. We might maintain a small local database or JSON file to store historical stats to compare changes over time (optional).

**UI/UX for dashboard:** The React frontend will likely have a **Dashboard page** showing the player’s profile (rank, icon, etc.), and sections for the above stats. Use clear charts or lists for each section. For example, a bar chart or list for Champion win rates, a line chart for recent performance trend, and an icon grid for playstyle traits. Keep paragraphs or lists concise and use visuals for quick scanning (the user should glean key info at a glance). We can use libraries like **Recharts** or **Chart.js** for graphs, and perhaps a UI framework like Material-UI or Chakra for layout, to expedite development of a polished interface.

## 3. In-Game Match Overview (Match-Specific Dashboard)

**Goal:** The moment a new match is detected, the app switches to a **match overview** view (similar to the League client’s loading screen, but enriched with stats like a Porofessor overlay). This view will display information about all 10 players in the match, divided by team, with insights such as ranks, champion picks, player strengths/weaknesses, and matchup notes. Essentially, it’s a scouting report for the ongoing match.

**Triggering and data gathering:** Once the Spectator API indicates a game is in progress, we use the returned **CurrentGameInfo** data to get details of the match. The Spectator response includes the list of participants (each with summoner name, champion ID, summoner spells, runes, etc.). From this, our backend immediately knows the champions and basic loadouts in play. We will then gather additional info for each participant in parallel, respecting rate limits:

* **Ranked Stats:** For each player (especially the 9 others, since we likely know the tracked user’s info already), call the League-V4 Ranked endpoint `GET /lol/league/v4/entries/by-summoner/{encryptedSummonerId}`. This gives their current rank (e.g. Gold II, 50 LP) and ranked win/loss record for the queue. We can cache these for the duration of the game since they won’t change mid-match. Showing each player’s rank and LP provides context on skill levels.

* **Champion Mastery / Experience:** We can check if a player is experienced on their current champion. A quick call to Champion Mastery API (`GET /lol/champion-mastery/v4/champion-masteries/by-summoner/{id}/by-champion/{champId}`) yields their mastery points and mastery level on that champion. If this returns very low points, it’s likely a **“First time”** or inexperienced pick – we will tag that (e.g. “First time \[champion]”). Conversely, if they have a mastery level 7 and hundreds of thousands of points, they are a veteran on that champ (could tag as “One-Trick” or “OTP” if their mastery is disproportionately high relative to others).

* **Recent Performance for Tags:** We might fetch a *short* recent match history for each player (e.g. last 5 games via Match-V5 by PUUID). This is more data-intensive (9 players * 5 matches = 45 match fetches, plus initial IDs fetches). To optimize, we can use a smaller count or only fetch for the most relevant stats. Alternatively, use the data in the Spectator info: it doesn’t provide performance stats, so likely we need at least the outcomes of recent games. An alternative approach is to rely on the ranked wins/losses: if a player’s ranked wins minus losses in the current rank is high, they might be on a win streak. However, Porofessor’s tags like “Hot Streak” usually mean they won several games in a row *recently*. We can derive a **“hot streak”** or **“cold streak”** tag by checking the last few game results from the match history: e.g. if they won their last 3+ games, tag “Hot Streak”, if they lost 5 in a row, tag “Tilted (Losing Streak)”. We will be mindful of rate limits – perhaps stagger these history calls or limit to just the enemy team to prioritize scouting opponents.

* **Role identification:** The Spectator API does not explicitly state roles/lanes, but we can infer from champion + summoner spells or use an algorithm. However, since we have 5 players per team with known champions, we can guess standard lane assignments (for instance, the champion tagged as * marksman * likely ADC, etc.). Porofessor uses a combination of champion and player history to guess roles. For our plan, we can assume standard meta positions based on champion classes, or simplify by listing all 5 without explicit lane labeling if uncertain. However, knowing roles is useful for matchup display (who is laning against whom). We can attempt a role assignment algorithm: for example, look at each team composition and assign one top, one jungle, one mid, one ADC, one support based on champion common roles and any inconsistencies resolved via mastery or past games data (as Porofessor does). This role info can be displayed and used to pair up players for lane matchup stats.

**Matchup and team stats display:** The **In-Game view** will be organized by teams (Blue vs Red). For each team, list the five players in their likely role order (Top, Jungle, Mid, ADC, Support). For each player, display a row or card containing:

* Summoner Name (with perhaps an icon for their rank tier).

* Champion they are playing (champion icon and name).

* Their **rank** and LP (e.g. *Gold II – 60 LP*).

* A few **quick stats/tags** about them:

  * Champion mastery level or an indicator if this is a first-time pick (e.g. “Mastery Lvl 1 – First Time!”).
  * A tag for recent form: “Hot Streak” or “Cold Streak” if applicable.
  * A tag for any notable playstyle trait: e.g. “Aggressive Laner” if they tend to get early kills (we could detect if in their history they have high average kills@10 or gold@10 leads) or “Late Game Player” if they have high winrate in long games (if such data is available from match history). These tags mimic the Porofessor style of summarizing a player’s habits.
  * Their **winrate on this champion** in recent games or season. For example, “70% winrate on 10 games” for the champion they picked (we can get this from the player’s match history by filtering champion). If direct data is hard to fetch live, we might pre-compute for the tracked user and perhaps skip for others or rely on Porofessor/LeagueofGraphs APIs if they exist (to avoid heavy computation). Alternatively, use the **Champion Mastery** combined with rank: a player with high mastery but low rank could imply a lot of games but maybe mediocre winrate. For simplicity, a rough indicator like mastery level can stand in for experience on champ, and ranked W/L for general skill.

* **Lane matchup info:** We should show head-to-head insights for each lane. For example, highlight the direct lane opponents and possibly show if one has historically had an edge. If we have champion winrate data (e.g. how the player performs against that specific enemy champion), that would be ideal but may be too granular to get in real-time. Instead, we could show **“Winrate vs lane opponent”** if available (Porofessor lists this). We can approximate by checking if the player has played against that champion in recent games and how it went, or use general champion matchup data from static sources (like if Champion A traditionally has a 55% winrate vs Champion B overall). For the plan, we note this as a nice-to-have: e.g. display a small icon or color if the matchup is favorable or not (which could simply be based on global matchup stats or nothing if unavailable in real-time).

* **Team statistics:** At a higher level, show aggregated info like the average rank of each team, or a **“team composition” score.** For example, if one team is much higher average Elo, note that. Or if one team’s players all have comfort picks (multiple high mastery champions) vs the other team has two first-time picks, that can be a point to highlight in the UI (perhaps as a summary line: “Blue Team has three players on signature champions (mastery lvl7), Red Team has two first-time picks”). We can derive this from the data we collect for each player.

All this data should be fetched **quickly** once the game is detected. We will utilize concurrency in Rust: spawn multiple async tasks for the 9 other players to get their info in parallel (Riot’s rate limits allow bursts up to 20 requests per second, so doing \~10-15 immediate calls is feasible if done once at game start). To remain safe, we might introduce a slight stagger or use a rate-limiter (some Riot API libraries handle this automatically). If performance is a concern, prioritize the most important calls (rank and some tags) first, and lazy-load others (e.g. load additional match history in the background even after the in-game view is shown, updating tags as data arrives).

**UI for In-Game view:** Design the layout so that it’s easy to scan during the loading screen countdown (which is usually short). A two-column layout (Blue left, Red right) could work, or a single column grouping by team. Each player’s entry should be compact but informative:

* Use **icons and color codes** for quick recognition (e.g. a border color or an icon for “hot streak” vs “cold streak”, small champion icon, rank emblem icon for their tier).
* Potentially highlight the **target user** (the one we are primarily tracking) in the list (maybe with a star or different highlight) so the user can quickly find their own stats vs the lobby.
* If screen space permits, a toggle to show/hide more detailed stats (like graphs of gold@10, etc.) per player could be included, but that might clutter the real-time use. It may be better to keep it simple in the live view and leave deep stats for post-game or in the dashboard.

We should also display a **timer or status** indicating that the match is ongoing and maybe showing the game time (the Spectator API gives a `gameLength` in seconds that updates). While in loading screen, gameLength will be 0 since it hasn’t started; once in game, it starts ticking. We can periodically update the UI with the current game time if desired (by either keeping the Spectator socket open or polling it occasionally even during the game, though continuous polling during the match may not be necessary for our overlay, since we focus on pre-game info).

**Porofessor-style tags and cues:** As mentioned, tags are derived from performance comparisons. For implementation, we’ll use simple rules:

* *“Good CS”* or *“Bad CS”* tag: compare the player’s average CS at 10 minutes to an expected benchmark for their role (we can use internal data or general benchmarks, e.g. an average top laner might have \~60 CS @10; if a player consistently has 40, tag “Low CS”).
* *“Aggressive”* tag: if a player’s kill participation or early kill rate is high relative to peers (e.g. always involved in first blood or has high avg kills by 15 min).
* *“Safe player”* tag: low death counts, but possibly also low kills (playing not to die).
* *“Roamer”*: if their playstyle shows high assists or they play champions known for roaming.
* *“Warding”*: if their wards placed per minute is high (support mains might get “Vision King”).
* *“Unranked/New”*: if a player has no rank data (could happen if account is new or unranked, then we tag accordingly so the user knows this player’s skill is uncertain).

These tags provide at-a-glance clues. We will display them next to each player name in a smaller font or icon form. It’s wise to cap at 2-3 tags per player so as not to overwhelm. Tags should be prioritized by importance (e.g. “First Time Champ” and “Hot Streak” are high-impact tags to call out; lesser ones like “Good CS” can be secondary).

The **match-specific view** essentially functions as a dynamic overlay that exists from loading screen until the match is finished.

## 4. Post-Match Transition & Data Refresh

**Goal:** Detect when the match ends and seamlessly switch the UI back to the persistent dashboard, updating stats with the latest match results. The app should *return to the out-of-game view automatically* once the tracked game concludes, and incorporate any new data from that game.

**Detecting match end:** There are a couple of ways to do this:

* Continue polling the Spectator API even while the game is ongoing, or resume polling near the expected end. The Spectator endpoint will start returning 404 again shortly after the game ends (once the game is no longer live). We could, for example, poll the spectator endpoint every 1 minute during the game (this would be 60 calls over an hour-long game, which is fine under limits) to check if it still finds the game. A 404 response indicates the game is over. This method is straightforward: as soon as we get 404 after having a game, we know it ended.
* Alternatively, use the Match-V5 API to check for a new completed match in the history. After a game ends, within a minute or so the result will appear in the player’s match list. We could periodically check `GET /lol/match/v5/matches/by-puuid/{puuid}/ids?start=0&count=1` to get the latest match ID. If it’s different from the one we saw started, that means the game has finished and been recorded (the match ID might be known from spectator data as `gameId` + region, but to avoid confusion, simply detecting a new match in history works). This approach might introduce a slight delay (until Riot reports the match), but ensures the game is truly done. We might combine both: use Spectator to catch the exact moment of end (404 appears) and then confirm by fetching the match result.

**UI transition:** Once the backend confirms the game is over, it will emit a `"gameEnded"` (or similar) event to the frontend. The React app, upon receiving this, will transition the view back to the Dashboard. We will tear down or hide the in-game component and show the out-of-game stats again. This can be a smooth transition (perhaps even with a small message like “Game finished. Returning to dashboard…” if needed).

**Data refresh:** Importantly, after a game ends we should update the user’s stats. The backend can immediately fetch the finished match details (via Match-V5) and update the cached stats for the player. For example, update their recent games list, recompute win rates (the champion they just played will have one more game in the stats, etc.). This way, when the dashboard is shown again, it reflects the latest performance. We should also update any metrics used for tags – for instance, if the user went on a win streak or broke a losing streak with that match, the trait tags may change.

To avoid heavy computation right as the game ends (which is a busy moment communicating with UI), we can do this refresh on a slight delay or in a separate thread: once game end is detected, schedule a task to fetch the match result and then emit an event or simply update the state that the React app can request. The React front could also proactively call a refresh command like `refreshStats()` on game end event, which the backend handles by returning updated data.

**Handling multiple sequential games:** If the user immediately goes into another queue, our system will pick that up as we continue polling. We should ensure that if a new game starts before the user ever alt-tabs to the app, we still handle it (this is an edge case: e.g. they play back-to-back games without checking the app). Our background polling will catch the new game; the UI might already be on dashboard (since it went back after first game). We will simply emit another `"gameStarted"` and the UI will swap to match view again. All caching of previous game can be cleared or archived as needed. We must also ensure we don’t mistakenly think the previous game is still on – but since we got a 404 (ended) and likely a new gameId from spectator for the next one, it’s distinguishable.

In summary, returning to the dashboard is about *state management*: toggling the `inGame` state off and refreshing the data displayed. With Tauri events and a robust backend, this can be handled cleanly without user intervention.

## 5. API Rate Limits and Call Optimization

**Riot API limits:** The Riot Developer API imposes strict rate limits on requests. For a standard developer key, the limit is typically **20 requests per second** and **100 requests per 2 minutes** for each region cluster. This means we have to be mindful not only of our polling frequency but also bursts of calls when gathering match data. Our design has the following patterns of API usage:

* Steady polling (Spectator API) at \~6 calls/minute (10s interval). This is well under the 100/2min limit. Even if we lowered to 5s (12 calls/min), it remains safe.
* Burst calls on game start: when a new match is detected, we might issue \~10-15 calls immediately (one for each of the other players’ rank/tag info). This burst *could* hit the 20 requests per second cap if not throttled. To avoid any 429 errors, we can throttle these using a short sleep between each or group them in two waves. Additionally, many Riot API libraries (like the Rust “Riven” library) have built-in rate limiting to queue requests appropriately. We will leverage such features or implement a simple counter to not exceed 20 rps (which essentially means not firing all 15 simultaneously; a brief 100ms gap between each would suffice).
* Post-game data fetch: fetching the match details and updating stats is a handful of calls (one match details call, maybe a couple more for any supplementary data). This is trivial relative to the limits.

We will also **utilize Riot’s response headers** for rate limit feedback. The API returns headers like `X-Method-Rate-Limit-Count` and `Retry-After` when a limit is reached. Our backend should handle a HTTP 429 (Too Many Requests) by backing off and trying again after the `Retry-After` period. In practice, if we stay within planned calls this won’t happen, but it’s good to code defensively. For maintainability, wrapping all Riot HTTP calls in a helper that checks for 429 and respects those headers is recommended.

**Caching strategies:** Caching is crucial to reduce unnecessary calls and improve responsiveness:

* **Summoner ID and basic profile** – cache indefinitely (or until user changes target). We only need to look this up once.
* **Static data (champions, items)** – use Riot’s Data Dragon. We will download a static champion list (mapping champion IDs to names, roles, icons) once and reuse it for displaying names and icons instead of calling champion API repeatedly. Data Dragon can be fetched at app startup or bundled with the app (since it updates only when new patches add champions).
* **Recent match history** – cache the results for the player’s recent games on the dashboard. If the user hasn’t played new games since last check, reuse the computed stats. We can store a hash or timestamp of the latest match fetched to know if we need to update. For example, if we know the last match ID we processed, we can check if a new one appeared.
* **Other players’ data in match** – since each new match will have potentially new players, we can’t cache a lot of that between matches (except if the same player appears frequently in the user’s games, which is rare except maybe duo partners). However, within a single match session, we should cache *during that game* any data fetched. For instance, if we fetched a player’s mastery and rank at game start, keep it in memory so if we re-draw UI or need it again we don’t call twice. This also helps if the UI is reopened during the game.

**Efficient updates via deltas:** Instead of re-fetching whole datasets, use delta updates where possible:

* The **Spectator polling** is effectively checking a delta (presence or absence of game). No heavy data is fetched until a game is found.
* For **match history**: Riot’s match list API supports start indexes, so we can fetch only new matches since last index. If we maintain how many matches we’ve seen, we could fetch just the next one on game end.
* For **live game data**: the Spectator info gives us champion picks and summoner names immediately. We then selectively fetch extra info per player. If a certain piece of info (say rank) was already known (perhaps the user’s own rank we knew from before), we skip that call.

We should also consider Riot’s **match timeline** (which provides event-by-event data) if we wanted to show in-game progress, but since we focus on pre-game and post-game summary, we likely won’t use timeline data in real-time. To avoid extra calls, we limit ourselves to needed endpoints.

One more optimization: **Batching calls by region.** If using Riven or similar library, we can often batch calls internally. Riot doesn’t have a bulk endpoint for multiple summoners in one call (aside from Match-v5 which can pull multiple match IDs at once up to 20). But e.g. the match IDs endpoint gives multiple IDs in one call (we use that for history). We will certainly use that to grab many match references in one request instead of calling one by one.

**Threading and concurrency:** On the Rust side, to keep the UI responsive, all API calls will be made asynchronously (using `reqwest` or an equivalent async HTTP client). The background polling will run in an async task. We can use **Tokio** (Tauri uses Tokio under the hood) to spawn tasks. For example, at startup we might spawn a task that loops on the spectator check. For bursts (like game start data fetch), we can use `join_all` for concurrent futures or spawn multiple tasks and then join them. The goal is to complete all data gathering ideally within the 10-15 seconds of champ select/loading screen time. If some slower data (like computing playstyle tags from match history) isn’t done by the time game is loading, it’s acceptable to fill in basic info first and update tags a few seconds later.

Finally, we must respect **long-term rate limits**: The 100/2min is the short limit; there are also daily limits for some API keys (though usually the main concern is the short window). Our usage is quite reasonable (even if user plays 10 games a day, that’s on the order of a few thousand calls total, which is fine for personal use). If scaling up or using a production API key, we would revisit these numbers and possibly implement a shared cache server or queue system. But for a standalone personal app, the above strategies suffice.

## 6. Frontend–Backend Integration and UI State Management

This section details **how** the React/TS frontend and Rust backend work together for smooth state transitions and data flow, ensuring responsiveness and a good user experience.

**State management approach:** We will maintain a high-level app state that includes whether the user is currently in a game or not, as well as the data needed for each view (dashboard data vs. live match data). For example, a simple `appState` object might have `{ inGame: boolean, dashboardStats: {...}, liveMatch: {...} }`. In React, this could be managed via React Context or a state library (like Zustand or Redux, depending on complexity). Given Tauri’s event-driven updates, a lightweight approach using React’s built-in context or hooks should suffice.

**Initial load:** When the app launches, the backend will likely do some initialization (e.g. fetch summoner ID if not provided, maybe load initial dashboard data). The frontend could show a loading spinner or splash (Tauri supports a splashscreen plugin) until things are ready. Once ready, the backend can emit an event or the frontend can call a command to get initial data. For instance, the frontend might call `getDashboardData()` command, which returns the compiled stats; the React app then sets state and shows the dashboard.

**Listening for events:** The React app will set up event listeners using the Tauri API (e.g. `import { listen } from '@tauri-apps/api/event';`). We will listen for our custom events like `"gameStarted"`, `"gameEnded"`, and possibly `"statsUpdated"`. For example, in a React `useEffect`, we might do:

```ts
listen('gameStarted', event => {
  const liveData = event.payload;
  setAppState(state => ({ ...state, inGame: true, liveMatch: liveData }));
});
```

This way, whenever the backend emits `gameStarted` with the payload of match info, the React state toggles to in-game and stores the match data. The UI can then render the `<MatchOverlay>` component using this data. Similarly, listen for `gameEnded` to set `inGame: false` and perhaps trigger a refresh of dashboard stats.

Tauri’s **event system** allows both global events (all windows) and window-specific events. In our single-window app, we can simply use global events (`emit_all` on backend to broadcast to the window). The events carry serialized JSON which is our data payload.

**Invoking backend commands:** In addition to passive listening, the frontend can actively request data or trigger actions. For example:

* A “Refresh” button on the dashboard could invoke a `refreshStats` command, which forces the backend to refetch the latest profile stats (maybe user suspects data changed, or just after linking a new summoner).
* If we allow user to change the tracked summoner from the UI, we would call a command like `setSummoner(name)` which the backend handles by updating the target Summoner ID and resetting state.

Tauri makes it straightforward: we annotate Rust functions with `#[tauri::command]` and they become callable via `window.__TAURI__.invoke('functionName', { args })`. The backend can return data which the frontend receives as a promise result. We will use this for any on-demand queries. However, the core flow (game detection) is push-based from backend.

**Background loop integration:** We need to ensure the background polling loop (for game start detection) starts when the app starts and continues running. In Tauri, we can set this up in the `setup` hook of the application. For instance, in `tauri::Builder::setup(|app| { ... })`, we could spawn a task:

```rust
let app_handle = app.handle();
std::thread::spawn(move || {
    loop {
        // perform Spectator API check
        if gameFound {
            app_handle.emit_all("gameStarted", game_info).unwrap();
            // possibly break or wait until game ends to continue loop
        }
        std::thread::sleep(std::time::Duration::from_secs(10));
    }
});
```

This pseudo-code shows using `emit_all` to send an event to the frontend. We might refine it to not loop continuously during a game; maybe the loop could be stateful itself (know if currently in a game to adjust behavior). Alternatively, simpler: always poll, and when in game, if `emit_all` fails or is not needed repeatedly, we manage that. Since Tauri events are multi-producer, multi-consumer, this is safe.

An even more structured approach is to use **commands that spawn tasks**. For example, have a command `startMonitoring()` that when called will spawn the background thread (passing in `tauri::AppHandle` or `Window` handle to use for emitting events). Actually, Tauri allows spawning inside commands and using a `Window` handle to emit to that window. We could invoke this command on startup from the frontend to kick off monitoring. But doing it in `setup` is fine too as it runs once.

**Ensuring thread safety:** We should be careful that the background thread doesn’t directly update UI state (it can’t; it must use events). Also, if multiple events fire quickly (imagine edge cases like two gameStarted events if logic went wrong), the frontend should handle gracefully (maybe ignore a second if already inGame). But our logic will likely set a flag `inGame` to true and stop sending additional “game start” until a “game end” happens.

**UI transitions:** The React side will conditionally render either the Dashboard component or the InGame component based on `appState.inGame`. This could be simply `{appState.inGame ? <MatchOverlay data={appState.liveMatch}/> : <Dashboard data={appState.dashboardStats}/>} ` in the JSX. We can enhance it with CSS transitions or animations for polish (e.g. fade out/in). The state update from the event listener will trigger React to re-render and swap the view almost instantly. The dashboard data (`dashboardStats`) may remain loaded in memory so that going back is instantaneous (we might refresh it in background, but we don’t have to blank it out – we can show last known stats until new ones compute).

**Error handling and feedback:** We’ll also integrate UI elements for any errors or status messages from the backend. For instance, if the Riot API key is invalid or rate limit is hit and causes delays, the backend could emit an event like `"error"` or `"status"` with a message. The frontend can listen and display a toast or message. This ensures the user is aware if, say, data might be outdated due to an API issue. Similarly, if the user enters a summoner name that’s not found, the backend can emit an event or the command can return an error that the frontend displays (“Summoner not found”).

**Responsiveness:** Both in terms of UI responsiveness and app performance:

* The UI should remain snappy. By offloading data fetching to Rust, we avoid blocking the UI thread. The React app just updates when data is ready.
* We’ll use loading indicators in components where data might still be coming. For example, when the match overlay first appears, if we haven’t yet fetched all opponent data, we can show a “Loading player stats…” on those entries, then fill them in as events come (we can emit events like `"playerData"` for each player as they return, or send partial data in the initial payload).
* The app should be efficient: Tauri apps are lightweight; Rust ensures low overhead; we avoid running heavy loops in JS. We will test that the 10s polling and occasional bursts don’t cause noticeable CPU or memory spikes. Using profiling tools or logging, we can verify the background thread doesn’t consume too much.

In summary, the integration uses **event-driven updates** from Rust -> React for game state changes and data updates, and **command invocations** from React -> Rust for user-driven actions or on-demand data. This decoupling, combined with a clear state management in React, will produce a responsive and maintainable application structure.

## 7. Libraries, Tools, and Best Practices for Accuracy & Performance

In building this application, we will leverage several libraries and adhere to Riot’s guidelines to improve development speed, accuracy of data, and overall performance:

* **Riot API Library (Rust):** Instead of hand-coding all HTTP requests and rate-limit handling, we can use an existing Rust crate like **Riven** or the community **riot-api** crate. Riven in particular is a robust choice: it’s a Rust library designed for Riot API integration that automatically handles rate limiting, retries, and maps all endpoints to typed data models. By using Riven, we gain reliability and maintainability – we can call functions for each endpoint (e.g. `riot_api.summoner_v4().get_by_summoner_name(name)` returning a Summoner DTO) rather than manually constructing URLs. It will also help ensure we don’t overshoot rate limits by queuing requests if needed, which simplifies compliance. If Riven is too heavyweight or we want finer control, we might use a simple HTTP client like **Reqwest** with our own logic, but the library’s built-in features are compelling.

* **Riot API Library (TypeScript) \[optional]:** If any part of the app were to fetch data from the frontend (for example, if we decided to use a client-side approach for some reason), libraries like **Galeforce** or **fightmegg/riot-api** in NPM could be used. However, since our plan is to centralize calls in Rust (to keep the key secure and avoid CORS issues), we likely won’t use a TS Riot API wrapper. The frontend will treat the backend as the data source.

* **Data Dragon & Static Data:** We will use Riot’s Data Dragon for static content (no library needed, just fetch the JSON or use a CDN). This provides champion data (names, images, stats). We can download the champion list JSON at build time or on first run. We should also grab champion icons (perhaps bundle a set of small icons for all champions in the app resources, or download on demand and cache to disk). This avoids calling champion endpoints repeatedly and gives a richer UI (display champ icons next to names, etc.). Data Dragon is versioned by patch, but it’s fine to use the latest for our purposes; champion IDs don’t change so it’s stable.

* **UI Libraries:** For the React frontend, to implement a modern interface quickly, consider using **component libraries** like **Mantine** or **Chakra UI** (which have ready-made components and theming) or even Riot’s own design style if desired. However, since we have very custom data visuals (stats, tags, etc.), we might build custom components. For data visualization, **Recharts**, **Victory** or **Chart.js** can create graphs (like performance over time, gold@10 vs games, etc.) easily. These libraries handle responsiveness and are well-tested, so we don’t need to draw charts from scratch. We should also ensure our layout is responsive to different window sizes if we want (though as a desktop app we might set a fixed window size or minimum size).

* **State Management:** If the state remains simple (just in vs out of game and some nested data), we can manage with React’s Context and hooks. If it grows, introducing **Zustand** (a lightweight state library) could simplify things – especially since Zustand can be easily integrated with Tauri events (we could write directly to the store in an event callback). Zustand is known for ease of use with React and would help keep our code organized if we have many pieces of state.

* **Coding with AI (Codex):** Since the user specifically mentioned building in Codex (OpenAI’s coding assistant), we should structure our development to leverage it effectively. This means writing clear, modular code and docstrings so that Codex can understand the context for each function. For example:

  * Write a detailed docstring for the `game_monitor()` function explaining that it polls the API, so if using Codex to implement it, the intent is clear.
  * Break tasks into small functions (Codex does better generating focused functions rather than one giant loop).
  * Use consistent naming (e.g. always refer to summonerId as `encryptedSummonerId` in code, etc.) so the AI doesn’t get confused with multiple terms.
  * While using Codex, we’d implement step by step: first a function to get Summoner ID, then one to get live game, then integrate into a loop, etc., verifying each. The plan we have can serve as a blueprint for prompting Codex for each part.

* **Logging and Debugging:** We should incorporate logging (perhaps with a Rust crate like **log** or just println during dev) to trace what’s happening (e.g. log “Game started detected at 12:00:00, gameId=XYZ”). This will help debugging issues. In production, we can tone it down or write to a log file. Codex can also help generate some of this boilerplate if prompted correctly.

* **Riot API compliance and rules:** We must ensure the app abides by Riot’s terms. Important points:

  * **No cheating or unintended advantage:** Our app only provides information that could be obtained via the official API or third-party sites that are openly available. We are not reading memory or providing info like enemy cooldowns that are not accessible normally. Thus, we comply with Riot’s policy on 3rd-party tools (which allows stat overlays but forbids tools that provide unreal information or automation).
  * **API Key security:** Never expose the key in the front-end. Tauri helps here since Rust can keep it. We might even allow the user to input their own API key if this is for personal use (some users might prefer to use their developer key; but if this app is distributed, we’d use our key and likely require a production key from Riot which has higher limits).
  * **Rate limit adherence:** As discussed, obey the 100/2min and 20/s limits. Using the provided headers and not creating multiple apps/keys to circumvent (explicitly disallowed).
  * **Privacy considerations:** Summoner names are public data in League, but we should still handle any personal data respectfully. If we log or store match history, it stays on the user’s machine. We should clarify that our app isn’t sending their data to any external server (unless we later add some cloud component). This is good for user trust and compliance (not a Riot rule per se, but a good practice).
  * **Avoiding API overuse:** If the app were to allow searching arbitrary summoners (not just one), it could be misused to scrape data. We will design it for one user at a time (the user’s own stats or their immediate lobby), to stay within intended use. If we add a feature like “search any summoner’s current game” (Porofessor has a feature to watch featured games), we’d incorporate similar rate limiting and perhaps require the user to actively trigger those searches to avoid constant background load.

* **Caching library/DB:** If we find the need to store more persistent data (like a database of past performance for deeper analysis or for showing progress over weeks), integrating a small embedded database like SQLite via `rusqlite` or using Sled (a Rust embedded KV store) could be beneficial. For now, it might be overkill, but it’s worth mentioning as an option for scaling. For example, storing every match’s stats in a local DB would allow the app to show long-term trends without refetching old matches again.

* **Testing tools:** Use Riot’s **development stub data** or a test summoner to test our app. Riot allows some test accounts or we can use a known summoner name (like a bot account) to simulate. Also, incorporate unit tests for our data processing logic (e.g. a function that computes tags from stats). For Codex specifically, writing tests or at least structured prompts for it can help verify logic.

* **Overwolf vs Tauri overlay:** A quick note – many existing LoL companion apps use Overwolf (like Porofessor) because Overwolf can create in-game overlays and has some integration. Our approach with Tauri is standalone and not an official overlay, meaning the user would need to alt-tab to see it or use windowed mode. If an always-on-top overlay is desired, we might need to use a transparent window layered on the game. Tauri can create a frameless window and we could attempt to make it click-through. However, Windows security might block drawing on a fullscreen game. If the user explicitly runs LoL in borderless window mode, an always-on-top window from Tauri could act like an overlay. We should research this if overlay functionality is required. If it’s complicated, we’ll stay with the assumption of a second screen or alt-tabbing scenario. (In any case, this doesn’t affect data handling, just UI presentation. It’s more of a user guidance thing – possibly mention in documentation that for best results run game in borderless mode and open the app next to it.)

* **Continuous Updates:** Keep the app adaptable to Riot API changes. Riot occasionally changes APIs (like the migration from v4 to v5 for match endpoints). Using libraries like Riven (which auto-generates from Riot’s swagger) can help keep up to date. We should also handle gracefully if an endpoint returns unexpected data or if the user’s region is down etc. The app could show a message “Riot API unavailable, please try again later” if such a case arises.

By following these recommendations, we ensure the application is not only feature-rich but also robust, compliant, and efficient. In summary, we will use well-supported libraries for Riot API and charts, implement caching of data to minimize calls, respect all rate limits, and structure the code in a way that both a developer and AI coding assistants can easily work with it. This results in a maintainable codebase and a smooth user experience, with quick stat lookups and updates that won’t lag the interface nor risk breaking Riot’s service rules.
